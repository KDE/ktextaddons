/*
  SPDX-FileCopyrightText: 2025 Laurent Montel <montel@kde.org>

  SPDX-License-Identifier: GPL-2.0-or-later
*/
#include "textautogeneratelistviewdelegate.h"
#include "core/textautogeneratemessagesmodel.h"
#include "textautogeneratecolorsandmessageviewstyle.h"
#include "textautogeneratedelegateutils.h"
#include "textautogeneratelistviewtextselection.h"
#include "textautogeneratetextwidget_debug.h"
#include <KLocalizedString>
#include <QAbstractTextDocumentLayout>
#include <QDesktopServices>
#include <QDrag>
#include <QListView>
#include <QMimeData>
#include <QPainter>
#include <QTextFrame>
#include <QTextFrameFormat>
#include <QToolTip>

using namespace TextAutoGenerateText;
TextAutoGenerateListViewDelegate::TextAutoGenerateListViewDelegate(QListView *view)
    : TextAutoGenerateListViewBaseDelegate{view}
    , mEditedIcon(QIcon::fromTheme(QStringLiteral("document-edit")))
    , mCopyIcon(QIcon::fromTheme(QStringLiteral("edit-copy")))
    , mCancelIcon(QIcon::fromTheme(QStringLiteral("dialog-cancel")))
    , mRefreshIcon(QIcon::fromTheme(QStringLiteral("view-refresh")))
    , mInformationIcon(QIcon::fromTheme(QStringLiteral("info")))
{
    connect(&TextAutoGenerateColorsAndMessageViewStyle::self(),
            &TextAutoGenerateColorsAndMessageViewStyle::needToUpdateColors,
            this,
            &TextAutoGenerateListViewDelegate::slotUpdateColors);
    slotUpdateColors();
}

TextAutoGenerateListViewDelegate::~TextAutoGenerateListViewDelegate() = default;

void TextAutoGenerateListViewDelegate::slotUpdateColors()
{
    const KColorScheme scheme = TextAutoGenerateColorsAndMessageViewStyle::self().schemeView();
    mEditingColorMode = scheme.foreground(KColorScheme::NegativeText).color();
    // Q_EMIT updateView();
}

void TextAutoGenerateListViewDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const
{
    painter->save();
    drawBackground(painter, option, index);
    painter->restore();

    const MessageLayout layout = doLayout(option, index);
    if (layout.textRect.isValid()) {
        painter->save();
        const TextAutoGenerateMessage::Sender sender = index.data(TextAutoGenerateMessagesModel::SenderRole).value<TextAutoGenerateMessage::Sender>();
        const bool isUser = (sender == TextAutoGenerateMessage::Sender::User);
        painter->setPen(QPen(Qt::NoPen));

        auto it = std::find_if(mIndexBackgroundColorList.cbegin(), mIndexBackgroundColorList.cend(), [index](const IndexBackgroundColor &key) {
            return key.index == index;
        });
        QColor messageBackgroundColor;
        if (it != mIndexBackgroundColorList.cend()) {
            messageBackgroundColor = it->color;
        }
        if (index.data(TextAutoGenerateMessagesModel::EditingRole).toBool()) {
            messageBackgroundColor = mEditingColorMode;
        }

        if (isUser) {
            if (messageBackgroundColor.isValid() && messageBackgroundColor != QColor(Qt::transparent)) {
                painter->setBrush(QBrush(messageBackgroundColor));
            } else {
                painter->setBrush(QBrush(option.palette.color(QPalette::Inactive, QPalette::Midlight)));
            }
        } else {
            painter->setBrush(QBrush(option.palette.color(QPalette::Active, QPalette::Mid)));
        }
        painter->setRenderHint(QPainter::Antialiasing);
        painter->drawRoundedRect(
            QRect(layout.decoRect.topLeft(), QSize(layout.decoRect.width(), layout.decoRect.height() - TextAutoGenerateDelegateUtils::spacingText() - 5)),
            TextAutoGenerateDelegateUtils::roundRectValue(),
            TextAutoGenerateDelegateUtils::roundRectValue());
        painter->restore();
        draw(painter, layout, index, option);
    }
    /*
    painter->save();
    painter->setPen(QPen(Qt::green));
    painter->drawRect(layout.decoRect);
    painter->restore();
    */
}

void TextAutoGenerateListViewDelegate::draw(QPainter *painter, const MessageLayout &layout, const QModelIndex &index, const QStyleOptionViewItem &option) const
{
    QRect rect = layout.textRect;
    auto *doc = documentForIndex(index, rect.width());
    if (!doc) {
        return;
    }
    painter->save();
    painter->translate(rect.left(), rect.top());
    const QRect clip(0, 0, rect.width(), rect.height());

    QAbstractTextDocumentLayout::PaintContext ctx;
    if (mTextSelection) {
        const QList<QAbstractTextDocumentLayout::Selection> selections = TextAutoGenerateDelegateUtils::selection(mTextSelection, doc, index, option);
        // Same as pDoc->drawContents(painter, clip) but we also set selections
        ctx.selections = selections;
        if (clip.isValid()) {
            painter->setClipRect(clip);
            ctx.clip = clip;
        }
    }
    doc->documentLayout()->draw(painter, ctx);
    painter->restore();
    drawDateAndIcons(painter, index, option, layout);
    drawInProgressIndicator(painter, index, option, layout);
}

void TextAutoGenerateListViewDelegate::drawInProgressIndicator(QPainter *painter,
                                                               const QModelIndex &index,
                                                               const QStyleOptionViewItem &option,
                                                               const MessageLayout &layout) const
{
    Q_UNUSED(option);
    auto it = std::find_if(mIndexScaleAndOpacitiesList.cbegin(), mIndexScaleAndOpacitiesList.cend(), [index](const IndexScaleAndOpacities &key) {
        return key.index == index;
    });
    if (it == mIndexScaleAndOpacitiesList.cend()) {
        return;
    }
    const auto scaleAndOpacities = (*it).scaleAndOpacities;
    painter->save();
    painter->setRenderHint(QPainter::Antialiasing);

    const int dotSize = 5;
    const int spacing = TextAutoGenerateDelegateUtils::iconSpacing();

    for (int i = 0; i < scaleAndOpacities.count(); ++i) {
        const TextAutoGenerateText::TextAutoGenerateMessageWaitingAnswerAnimation::ScaleAndOpacity value = scaleAndOpacities.value(i);
        painter->setOpacity(value.opacity);
        // qDebug() << " value " << value;
        painter->save();
        painter->translate(layout.inProgressRect.x() + spacing + i * (dotSize + spacing), layout.inProgressRect.top() + layout.inProgressRect.height() / 2);
        painter->rotate(45);
        painter->scale(value.scale, value.scale);
        painter->setBrush(Qt::black);
        painter->drawEllipse(-dotSize / 2, -dotSize / 2, dotSize, dotSize);
        painter->restore();
    }
    painter->restore();
}

void TextAutoGenerateListViewDelegate::drawDateAndIcons(QPainter *painter,
                                                        const QModelIndex &index,
                                                        const QStyleOptionViewItem &option,
                                                        const MessageLayout &layout) const
{
    const bool isMouseOver = index.data(TextAutoGenerateMessagesModel::MouseHoverRole).toBool();
    if (layout.dateSize.isValid()) {
        const QPen origPen = painter->pen();
        const qreal margin = TextAutoGenerateDelegateUtils::leftLLMIndent();
        const QString dateStr = index.data(TextAutoGenerateMessagesModel::DateTimeStrRole).toString();

        /*
        // qDebug() << " draw date" << dateAreaRect << layout.decoRect;
        painter->save();
        painter->setPen(QPen(Qt::yellow));
        painter->drawRect(dateAreaRect);
        painter->restore();
        */

        const QRect dateTextRect = QStyle::alignedRect(Qt::LayoutDirectionAuto, Qt::AlignCenter, layout.dateSize, layout.dateAreaRect);
        QColor lightColor(painter->pen().color());
        lightColor.setAlpha(60);
        painter->setPen(lightColor);
        painter->drawText(dateTextRect, dateStr);
        // qDebug() << " dateTextRect" << dateTextRect;
        const int lineY = (layout.dateAreaRect.top() + layout.dateAreaRect.bottom()) / 2;
        painter->drawLine(layout.dateAreaRect.left(), lineY, dateTextRect.left() - margin, lineY);
        int iconSizeAreaWidth = 0;
        const bool inProgress = index.data(TextAutoGenerateMessagesModel::FinishedRole).toBool();
        if (isMouseOver) {
            if (!inProgress) {
                iconSizeAreaWidth = 3 * (buttonIconSize(option) + TextAutoGenerateDelegateUtils::iconSpacing());
            } else {
                iconSizeAreaWidth = 2 * (buttonIconSize(option) + TextAutoGenerateDelegateUtils::iconSpacing());
            }
        }
        painter->drawLine(dateTextRect.right() + margin, lineY, layout.dateAreaRect.right() - iconSizeAreaWidth, lineY);
        painter->setPen(origPen);
    }

    if (isMouseOver) {
        const bool waitingAnswer = index.data(TextAutoGenerateMessagesModel::WaitingAnswerRole).toBool();
        if (layout.editedIconRect.isValid() && !waitingAnswer) {
            mEditedIcon.paint(painter, layout.editedIconRect);
        }
        if (layout.copyIconRect.isValid()) {
            mCopyIcon.paint(painter, layout.copyIconRect);
        }
        if (layout.cancelIconRect.isValid()) {
            mCancelIcon.paint(painter, layout.cancelIconRect);
        }
        if (layout.refreshIconRect.isValid() && !waitingAnswer) {
            mRefreshIcon.paint(painter, layout.refreshIconRect);
        }
        if (layout.infoIconRect.isValid() && !waitingAnswer) {
            mInformationIcon.paint(painter, layout.infoIconRect);
        }
    }
}

QSize TextAutoGenerateListViewDelegate::sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const
{
    const QByteArray uuid = index.data(TextAutoGenerateMessagesModel::UuidRole).toByteArray();
    auto it = mSizeHintCache.find(uuid);
    if (it != mSizeHintCache.end()) {
        const QSize result = it->value;
        qCDebug(TEXTAUTOGENERATETEXT_WIDGET_LOG) << "TextAutoGenerateListViewDelegate: SizeHint found in cache: " << result;
        return result;
    }

    const TextAutoGenerateListViewDelegate::MessageLayout layout = doLayout(option, index);

    int additionalHeight = 0;
    // A little bit of margin below the very last item, it just looks better
    if (index.row() == index.model()->rowCount() - 1) {
        additionalHeight += 4;
    }

    const QSize size = {layout.decoRect.width(), layout.decoRect.height() + additionalHeight + (layout.dateSize.isValid() ? layout.dateSize.height() : 16)};
    if (!size.isEmpty()) {
        mSizeHintCache.insert(uuid, size);
    }
    return size;
}

int TextAutoGenerateListViewDelegate::buttonIconSize(const QStyleOptionViewItem &option) const
{
    return option.widget->style()->pixelMetric(QStyle::PM_ButtonIconSize);
}

TextAutoGenerateListViewDelegate::MessageLayout TextAutoGenerateListViewDelegate::doLayout(const QStyleOptionViewItem &option, const QModelIndex &index) const
{
    const int iconSize = buttonIconSize(option);
    TextAutoGenerateListViewDelegate::MessageLayout layout;
    QRect usableRect = option.rect;
    const TextAutoGenerateMessage::Sender sender = index.data(TextAutoGenerateMessagesModel::SenderRole).value<TextAutoGenerateMessage::Sender>();
    const bool isUser = (sender == TextAutoGenerateMessage::Sender::User);
    const int indent = isUser ? TextAutoGenerateDelegateUtils::leftUserIndent() : TextAutoGenerateDelegateUtils::leftLLMIndent();
    if (!isUser) {
        const QString dateStr = index.data(TextAutoGenerateMessagesModel::DateTimeStrRole).toString();
        layout.dateSize = option.fontMetrics.size(Qt::TextSingleLine, dateStr);
        usableRect.setBottom(usableRect.bottom() + layout.dateSize.height());
    } else {
        usableRect.setBottom(usableRect.bottom() + iconSize);
    }

    int maxWidth = qMax(30, option.rect.width() - indent - TextAutoGenerateDelegateUtils::rightIndent());
    const QSize textSize = documentSizeHint(index, maxWidth, option, &layout.baseLine);
    if (isUser) {
        maxWidth = qMax(30, textSize.width() + TextAutoGenerateDelegateUtils::rightIndent() + TextAutoGenerateDelegateUtils::marginText());
    }

    if (isUser) {
        layout.textRect = QRect(option.rect.width() - maxWidth,
                                usableRect.top() + TextAutoGenerateDelegateUtils::spacingText() * 2,
                                maxWidth - TextAutoGenerateDelegateUtils::marginText() * 2,
                                textSize.height() + TextAutoGenerateDelegateUtils::spacingText() * 2);

        layout.decoRect = QRect(layout.textRect.x() - TextAutoGenerateDelegateUtils::rightIndent(),
                                usableRect.top() + TextAutoGenerateDelegateUtils::spacingText(),
                                maxWidth,
                                layout.textRect.height() + TextAutoGenerateDelegateUtils::spacingText() * 3);

    } else {
        layout.textRect = QRect(indent + TextAutoGenerateDelegateUtils::marginText(),
                                usableRect.top() + TextAutoGenerateDelegateUtils::spacingText() * 2,
                                maxWidth - TextAutoGenerateDelegateUtils::marginText() * 2,
                                textSize.height() + TextAutoGenerateDelegateUtils::spacingText() * 2);

        layout.decoRect = QRect(indent,
                                usableRect.top() + TextAutoGenerateDelegateUtils::spacingText(),
                                maxWidth,
                                layout.textRect.height() + TextAutoGenerateDelegateUtils::spacingText() * 3);
    }
    layout.dateAreaRect = QRect(layout.decoRect.x(),
                                layout.textRect.y() + layout.textRect.height() + TextAutoGenerateDelegateUtils::spacingText(),
                                layout.decoRect.width(),
                                qMax(layout.dateSize.height(), iconSize)); // the whole row

    int positionIcon = layout.decoRect.right() - iconSize;
    const int lineY = (layout.dateAreaRect.top() + layout.dateAreaRect.bottom() - iconSize) / 2;
    const bool waitingAnswer = index.data(TextAutoGenerateMessagesModel::WaitingAnswerRole).toBool();
    if (isUser && !waitingAnswer) {
        layout.editedIconRect = QRect(positionIcon, lineY, iconSize, iconSize);
        positionIcon -= iconSize + TextAutoGenerateDelegateUtils::iconSpacing();
    } else {
        const bool inProgress = index.data(TextAutoGenerateMessagesModel::FinishedRole).toBool();
        if (!inProgress) {
            layout.cancelIconRect = QRect(positionIcon, lineY, iconSize, iconSize);
            positionIcon -= iconSize + TextAutoGenerateDelegateUtils::iconSpacing();
        }
    }
    layout.copyIconRect = QRect(positionIcon, lineY, iconSize, iconSize);

    if (!isUser) {
        positionIcon -= iconSize + TextAutoGenerateDelegateUtils::iconSpacing();
        layout.refreshIconRect = QRect(positionIcon, lineY, iconSize, iconSize);

        layout.infoIconRect = QRect(layout.textRect.topRight().x(), layout.textRect.topRight().y(), iconSize, iconSize);
    }

    const QSize progressIndicatorSize = TextAutoGenerateDelegateUtils::progressIndicatorSize();
    layout.inProgressRect = QRect(layout.textRect.topRight().x() - progressIndicatorSize.width(),
                                  layout.textRect.y() + layout.textRect.height() - progressIndicatorSize.height(),
                                  progressIndicatorSize.width(),
                                  progressIndicatorSize.height());

    return layout;
}

bool TextAutoGenerateListViewDelegate::mouseEvent(QEvent *event, const QStyleOptionViewItem &option, const QModelIndex &index)
{
    const QEvent::Type eventType = event->type();
    if (eventType == QEvent::MouseButtonRelease) {
        auto mev = static_cast<QMouseEvent *>(event);
        const TextAutoGenerateListViewDelegate::MessageLayout layout = doLayout(option, index);
        if (handleMouseEvent(mev, layout.decoRect, option, index)) {
            return true;
        }
    } else if (eventType == QEvent::MouseButtonPress || eventType == QEvent::MouseMove || eventType == QEvent::MouseButtonDblClick) {
        auto mev = static_cast<QMouseEvent *>(event);
        if (mev->buttons() & Qt::LeftButton) {
            const TextAutoGenerateListViewDelegate::MessageLayout layout = doLayout(option, index);
            if (handleMouseEvent(mev, layout.decoRect, option, index)) {
                return true;
            }
        }
    }
    return false;
}

bool TextAutoGenerateListViewDelegate::helpEvent(QHelpEvent *helpEvent, QAbstractItemView *view, const QStyleOptionViewItem &option, const QModelIndex &index)
{
    if (!index.isValid()) {
        return false;
    }
    if (helpEvent->type() == QEvent::ToolTip) {
        const TextAutoGenerateListViewDelegate::MessageLayout layout = doLayout(option, index);
        const QPoint helpEventPos{helpEvent->pos()};
        if (layout.textRect.contains(helpEventPos)) {
            const auto *doc = documentForIndex(index, layout.textRect.width());
            if (!doc) {
                return false;
            }

            const QPoint pos = helpEvent->pos() - layout.textRect.topLeft();
            QString formattedTooltip;
            if (TextAutoGenerateDelegateUtils::generateToolTip(doc, pos, formattedTooltip)) {
                QToolTip::showText(helpEvent->globalPos(), formattedTooltip, view);
                return true;
            }
            return true;
        }
        if (layout.editedIconRect.contains(helpEventPos)) {
            QToolTip::showText(helpEvent->globalPos(), i18nc("@info:tooltip", "Edit..."), view);
            return true;
        }
        if (layout.copyIconRect.contains(helpEventPos)) {
            QToolTip::showText(helpEvent->globalPos(), i18nc("@info:tooltip", "Copy"), view);
            return true;
        }
        if (layout.cancelIconRect.contains(helpEventPos)) {
            QToolTip::showText(helpEvent->globalPos(), i18nc("@info:tooltip", "Cancel"), view);
            return true;
        }
        if (layout.refreshIconRect.contains(helpEventPos)) {
            QToolTip::showText(helpEvent->globalPos(), i18nc("@info:tooltip", "Refresh"), view);
            return true;
        }
        if (layout.infoIconRect.contains(helpEventPos)) {
            const QString modelInfo = index.data(TextAutoGenerateMessagesModel::ModelInfoRole).toString();
            QToolTip::showText(helpEvent->globalPos(), modelInfo, view);
            return true;
        }
    }
    return false;
}

QTextDocument *TextAutoGenerateListViewDelegate::documentForIndex(const QModelIndex &index, int width) const
{
    Q_ASSERT(index.isValid());
    const QByteArray uuid = index.data(TextAutoGenerateMessagesModel::UuidRole).toByteArray();
    Q_ASSERT(!uuid.isEmpty());
    auto it = mDocumentCache.find(uuid);
    if (it != mDocumentCache.end()) {
        auto ret = it->value.get();
        if (width != -1 && !qFuzzyCompare(ret->textWidth(), width)) {
            ret->setTextWidth(width);
        }
        return ret;
    }

    const QString text = index.data(TextAutoGenerateMessagesModel::MessageRole).toString();
    if (text.isEmpty()) {
        return nullptr;
    }
    auto doc = createTextDocument(text, width);
    auto ret = doc.get();
    mDocumentCache.insert(uuid, std::move(doc));
    return ret;
}

bool TextAutoGenerateListViewDelegate::maybeStartDrag(QMouseEvent *event, const QStyleOptionViewItem &option, const QModelIndex &index)
{
    const TextAutoGenerateListViewDelegate::MessageLayout layout = doLayout(option, index);
    if (maybeStartDrag(event, layout.textRect, option, index)) {
        return true;
    }
    return false;
}

bool TextAutoGenerateListViewDelegate::maybeStartDrag(QMouseEvent *mouseEvent, QRect messageRect, const QStyleOptionViewItem &option, const QModelIndex &index)
{
    if (!mTextSelection->mightStartDrag()) {
        return false;
    }
    if (mTextSelection->hasSelection()) {
        const QPoint pos = mouseEvent->pos() - messageRect.topLeft();
        const auto *doc = documentForIndex(index, messageRect.width());
        const int charPos = doc->documentLayout()->hitTest(pos, Qt::FuzzyHit);
        if (charPos != -1 && mTextSelection->contains(index, charPos)) {
            auto mimeData = new QMimeData;
            mimeData->setHtml(mTextSelection->selectedText(TextAutoGenerateListViewTextSelection::Format::Html));
            mimeData->setText(mTextSelection->selectedText(TextAutoGenerateListViewTextSelection::Format::Text));
            auto drag = new QDrag(const_cast<QWidget *>(option.widget));
            drag->setMimeData(mimeData);
            drag->exec(Qt::CopyAction);
            mTextSelection->setMightStartDrag(false); // don't clear selection on release
            return true;
        }
    }
    return false;
}
bool TextAutoGenerateListViewDelegate::handleMouseEvent(QMouseEvent *mouseEvent,
                                                        QRect messageRect,
                                                        const QStyleOptionViewItem &option,
                                                        const QModelIndex &index)
{
    Q_UNUSED(option)
    if (!messageRect.contains(mouseEvent->pos())) {
        return false;
    }

    const QPoint pos = mouseEvent->pos() - messageRect.topLeft();
    const QEvent::Type eventType = mouseEvent->type();

    // Text selection
    switch (eventType) {
    case QEvent::MouseButtonPress:
        mTextSelection->setMightStartDrag(false);
        if (const auto *doc = documentForIndex(index, messageRect.width())) {
            const int charPos = doc->documentLayout()->hitTest(pos, Qt::FuzzyHit);
            qCDebug(TEXTAUTOGENERATETEXT_WIDGET_LOG) << "pressed at pos" << charPos;
            if (charPos == -1) {
                return false;
            }
            if (mTextSelection->contains(index, charPos) && doc->documentLayout()->hitTest(pos, Qt::ExactHit) != -1) {
                mTextSelection->setMightStartDrag(true);
                return true;
            }

            // QWidgetTextControl also has code to support selectBlockOnTripleClick, shift to extend selection
            // (look there if you want to add these things)

            mTextSelection->setTextSelectionStart(index, charPos);
            return true;
        } else {
            mTextSelection->clear();
        }
        break;
    case QEvent::MouseMove:
        if (!mTextSelection->mightStartDrag()) {
            if (const auto *doc = documentForIndex(index, messageRect.width())) {
                const int charPos = doc->documentLayout()->hitTest(pos, Qt::FuzzyHit);
                if (charPos != -1) {
                    // QWidgetTextControl also has code to support isPreediting()/commitPreedit(), selectBlockOnTripleClick
                    mTextSelection->setTextSelectionEnd(index, charPos);
                    return true;
                }
            }
        }
        break;
    case QEvent::MouseButtonRelease: {
        qCDebug(TEXTAUTOGENERATETEXT_WIDGET_LOG) << "released";
        const TextAutoGenerateListViewDelegate::MessageLayout layout = doLayout(option, index);
        TextAutoGenerateDelegateUtils::setClipboardSelection(mTextSelection);
        // Clicks on links
        if (!mTextSelection->hasSelection()) {
            if (const auto *doc = documentForIndex(index, messageRect.width())) {
                const QString link = doc->documentLayout()->anchorAt(pos);
                if (!link.isEmpty()) {
                    QDesktopServices::openUrl(QUrl(link));
                    return true;
                }
            }
        } else if (mTextSelection->mightStartDrag()) {
            // clicked into selection, didn't start drag, clear it (like kwrite and QTextEdit)
            mTextSelection->clear();
        }
        if (layout.editedIconRect.contains(mouseEvent->pos())) {
            Q_EMIT editMessage(index);
            return true;
        } else if (layout.copyIconRect.contains(mouseEvent->pos())) {
            Q_EMIT copyMessage(index);
            return true;
        } else if (layout.cancelIconRect.contains(mouseEvent->pos())) {
            Q_EMIT cancelRequested(index);
            return true;
        } else if (layout.refreshIconRect.contains(mouseEvent->pos())) {
            Q_EMIT refreshRequested(index);
            return true;
        }
        // don't return true here, we need to send mouse release events to other helpers (ex: click on image)
        break;
    }
    case QEvent::MouseButtonDblClick:
        if (!mTextSelection->hasSelection()) {
            if (const auto *doc = documentForIndex(index, messageRect.width())) {
                const int charPos = doc->documentLayout()->hitTest(pos, Qt::FuzzyHit);
                qCDebug(TEXTAUTOGENERATETEXT_WIDGET_LOG) << "double-clicked at pos" << charPos;
                if (charPos == -1) {
                    return false;
                }
                mTextSelection->selectWordUnderCursor(index, charPos);
                return true;
            }
        }
        break;
    default:
        break;
    }

    return false;
}

void TextAutoGenerateListViewDelegate::needUpdateIndexBackground(const QPersistentModelIndex &index, const QColor &color)
{
    removeNeedUpdateIndexBackground(index);
    const IndexBackgroundColor back{.index = index, .color = color};
    mIndexBackgroundColorList.append(std::move(back));
}

void TextAutoGenerateListViewDelegate::removeNeedUpdateIndexBackground(const QPersistentModelIndex &index)
{
    auto it = std::find_if(mIndexBackgroundColorList.cbegin(), mIndexBackgroundColorList.cend(), [index](const IndexBackgroundColor &key) {
        return key.index == index;
    });
    if (it != mIndexBackgroundColorList.cend()) {
        mIndexBackgroundColorList.erase(it);
    }
}

void TextAutoGenerateListViewDelegate::needUpdateWaitingAnswerAnimation(
    const QPersistentModelIndex &index,
    const QList<TextAutoGenerateMessageWaitingAnswerAnimation::ScaleAndOpacity> &scaleAndOpacities)
{
    removeNeedUpdateWaitingAnswerAnimation(index);
    const IndexScaleAndOpacities back{.index = index, .scaleAndOpacities = scaleAndOpacities};
    mIndexScaleAndOpacitiesList.append(std::move(back));
}

void TextAutoGenerateListViewDelegate::removeNeedUpdateWaitingAnswerAnimation(const QPersistentModelIndex &index)
{
    auto it = std::find_if(mIndexScaleAndOpacitiesList.cbegin(), mIndexScaleAndOpacitiesList.cend(), [index](const IndexScaleAndOpacities &key) {
        return key.index == index;
    });
    if (it != mIndexScaleAndOpacitiesList.cend()) {
        mIndexScaleAndOpacitiesList.erase(it);
    }
}

#include "moc_textautogeneratelistviewdelegate.cpp"

/*
  SPDX-FileCopyrightText: 2025 Laurent Montel <montel@kde.org>

  SPDX-License-Identifier: GPL-2.0-or-later
*/
#include "textautogeneratesearchlistviewdelegate.h"
#include "core/textautogeneratesearchmessagesmodel.h"
#include <QListView>
#include <QPainter>

using namespace TextAutoGenerateText;
TextAutoGenerateSearchListViewDelegate::TextAutoGenerateSearchListViewDelegate(QListView *view)
    : TextAutoGenerateListViewBaseDelegate{view}
{
}

TextAutoGenerateSearchListViewDelegate::~TextAutoGenerateSearchListViewDelegate() = default;

QTextDocument *TextAutoGenerateSearchListViewDelegate::documentForIndex(const QModelIndex &index, int width) const
{
    Q_ASSERT(index.isValid());
    const QByteArray uuid = index.data(TextAutoGenerateSearchMessagesModel::MessageUuid).toByteArray();
    Q_ASSERT(!uuid.isEmpty());
    auto it = mDocumentCache.find(uuid);
    if (it != mDocumentCache.end()) {
        auto ret = it->value.get();
        if (width != -1 && !qFuzzyCompare(ret->textWidth(), width)) {
            ret->setTextWidth(width);
        }
        return ret;
    }

    const QString text = index.data(TextAutoGenerateSearchMessagesModel::PreviewText).toString();
    if (text.isEmpty()) {
        return nullptr;
    }
    auto doc = createTextDocument(text, width);
    auto ret = doc.get();
    mDocumentCache.insert(uuid, std::move(doc));
    return ret;
}
#if 0
void TextAutoGenerateSearchListViewDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const
{
    painter->save();
    drawBackground(painter, option, index);
    painter->restore();

    const MessageLayout layout = doLayout(option, index);
    if (layout.textRect.isValid()) {
        painter->save();
        const TextAutoGenerateMessage::Sender sender = index.data(TextAutoGenerateMessagesModel::SenderRole).value<TextAutoGenerateMessage::Sender>();
        const bool isUser = (sender == TextAutoGenerateMessage::Sender::User);
        painter->setPen(QPen(Qt::NoPen));

        auto it = std::find_if(mIndexBackgroundColorList.cbegin(), mIndexBackgroundColorList.cend(), [index](const IndexBackgroundColor &key) {
            return key.index == index;
        });
        QColor messageBackgroundColor;
        if (it != mIndexBackgroundColorList.cend()) {
            messageBackgroundColor = it->color;
        }
        if (index.data(TextAutoGenerateMessagesModel::EditingRole).toBool()) {
            messageBackgroundColor = mEditingColorMode;
        }

        if (isUser) {
            if (messageBackgroundColor.isValid() && messageBackgroundColor != QColor(Qt::transparent)) {
                painter->setBrush(QBrush(messageBackgroundColor));
            } else {
                painter->setBrush(QBrush(option.palette.color(QPalette::Inactive, QPalette::Midlight)));
            }
        } else {
            painter->setBrush(QBrush(option.palette.color(QPalette::Active, QPalette::Mid)));
        }
        painter->setRenderHint(QPainter::Antialiasing);
        painter->drawRoundedRect(
            QRect(layout.decoRect.topLeft(), QSize(layout.decoRect.width(), layout.decoRect.height() - TextAutoGenerateDelegateUtils::spacingText() - 5)),
            TextAutoGenerateDelegateUtils::roundRectValue(),
            TextAutoGenerateDelegateUtils::roundRectValue());
        painter->restore();
        draw(painter, layout, index, option);
    }
    /*
    painter->save();
    painter->setPen(QPen(Qt::green));
    painter->drawRect(layout.decoRect);
    painter->restore();
    */
}

void TextAutoGenerateListViewDelegate::draw(QPainter *painter, const MessageLayout &layout, const QModelIndex &index, const QStyleOptionViewItem &option) const
{
    QRect rect = layout.textRect;
    auto *doc = documentForIndex(index, rect.width());
    if (!doc) {
        return;
    }
    painter->save();
    painter->translate(rect.left(), rect.top());
    const QRect clip(0, 0, rect.width(), rect.height());

    QAbstractTextDocumentLayout::PaintContext ctx;
    if (mTextSelection) {
        const QList<QAbstractTextDocumentLayout::Selection> selections = TextAutoGenerateDelegateUtils::selection(mTextSelection, doc, index, option);
        // Same as pDoc->drawContents(painter, clip) but we also set selections
        ctx.selections = selections;
        if (clip.isValid()) {
            painter->setClipRect(clip);
            ctx.clip = clip;
        }
    }
    doc->documentLayout()->draw(painter, ctx);
    painter->restore();
}
#endif

#include "moc_textautogeneratesearchlistviewdelegate.cpp"
